# Iterators

## Iterator(반복자란?)

- 컨테이너의 한 지점을 가리키는 객체이다.
- 컨테이너의 종류와 내부 구조에 상관 없이 한 요소를 가리키는 목적으로 사용된다.
- 반복자를 알고리즘과 컨테이너를 연결하는 매개체라고 한다.
- 임의의 알고리즘을 연결하여 STL의 일반성을 확보하는 가장 중요한 장치이다.

## 기본 연산자

> ++, --, *, ==, >, <
- 해당 연산들은 모든 반복자에 대해 동일한 의미를 가진다.
- 반복자를 사용하는 방법은 일반화되어 있어 컨테이너 내부구조에 상관없이 동일 방법으로 연산할 수 있다.
- 알고리즘의 내부 코드는 컨테이너를 모르며 이를 직접 다루지 않고 반복자를 통해서만 요소에 접근한다.
	- ex) find 함수. 벡터나 리스트의 내부 구조가 완전히 다르지만 반복자만 잘 정의하면
		두 컨테이너를 동일한 방법으로 검색할 수 있다.

## 반복자 구간

모든 알고리즘 함수들은 작업 대상을 전달받기 위해 반복자를 인수로 받아들인다..
대개 두 개의 반복자로 표현되는 반복자 구간(iterator range)에서 구간내의 모든 요소에 대해 적용한다.

- [begin <= x < end)
- end : 마지막 요소의 다음점()

### 루프에서 부등호 < 부등비교
```C++
InIt find(InIt first, InIt last, const T& val)

{
	for (;first != last; ++first)	// 왜 부등호를 쓰지않고 부등비교를 쓸까?
		if (*first == val) break;
	return first;
}
```
- 반복자는 대소 비교를 하지 않고 항상 부등 비교를 한다.
	- 반복자는 대소 비교가 불가능하기 때문이다.
	- 리스트의 반복자는 흩어져있는 노드의 포인터이다. 앞쪽 노드가 앞쪽 번지에 있다고 보장할 수 없다.

### last가 처리 대상이 아니라서 좋은점
- 만약 last도 처리 대상에 포함된다면 루프가 복잡해지고 에러 처리 방법이 묘연해진다.
- 길이를 계산하는 방법이 명료해진다(last - first)
- last를 반환하는 것을 에러 처리로 쓸 수 있다.(탐색시 탐색원소가 없을때 last반환)

### 반복자의 주의할 점 : 반복자의 유효성 검증x

- STL 알고리즘은 반복자의 유효성을 전혀 점검하지 않으며 항상 유효하다고 가정한다.
- STL도 결국 범위를 점검하지 않는 C언어의 한계를 벗어나지 못했다. 왜? 성능때문에.
	- 반복자를 참조할 때마다 일일이 점검하려면 희생을 감수해야 하기 때문.
	- 그러나 보통 반복자가 특정 구간내에서만 움직이므로 범위를 점검치 않는 점이 큰 문제는 아니다.