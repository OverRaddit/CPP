# 캐스팅

## C 스타일의 형 변환

- 명시적 형변환을 해주는 연산자
- 강력해서 변환하지 못하는 대상이 없다.

but...
- 실수를 찾아내기 힘들고 의도를 구분하기에도 힘들다.

##

C++스타일의 캐스팅 오류를 try-catch로 잡아낼 수 있을까?

## static_cast

- 컴파일 타임에 형변환이 가능한지 검사한다(정적)

## 업캐스팅과 다운캐스팅

- 업캐스팅(자식->부모)
- 더 작은 메모리의 부모가 더 큰 자식의 메모리를 가리킨다.
	- safe

- 다운캐스팅(부모->자식)
- 더 큰 메모리의 자식이 더 작은 부모의 메모리를 가르킨다.
	- unsafe
	- 자식포인터로 부모의 메모리 바깥을 가리킬 수 있게 된다.

## reinterpret_cast

- 허용하지 않는 형변환을 강제적으로 형변환할때 사용한다.
- 포인터/참조와 관련된 형변환만 지원한다.
- **연관없는 두 포인터 형 사이의 변환을 허용**
- 이름 그대로, 재해석한다고 볼 수 있다.

## dynamic_cast

- 가상함수테이블을 통해서 변환될 자료형을 구분짓는다.



 ===================================

# 상속에서의 형변환

부모의 포인터로 자식 객체를 가리킬 수 있다.

부모의 포인터가 가리키는 객체가 부모 객체인지 자식 객체인지,
컴파일 타임에서는 알 수 없다. (static_cast를 써야하는지 판단하기 어려움)

이는 런타임에 알 수 있다. (dynamic_cast가 효과적)

## RTTI (Runtime Type Information/Identification)

가상함수를 사용할때...

가상함수 기능을 사용하기 위해서도 RTTI가 필요.

가상함수를 클래스안에 넣으면 해당 클래스는 vptr가 생기고

이 vptr가 참조하는 것은 실제 메모리에 존재하는 해당 객체의 vtable이다.

즉 현재 가리키는 객체의 vptr를 참조함으로써 이것이 무슨 객체인지 알 수 있다.