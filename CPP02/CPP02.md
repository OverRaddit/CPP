# 새로운 규칙

기본 생성자는 설명 생략한다.

## 복사 생성자

복사생성자란?
	다른 객체를 복사하여 생성되는 것.
	자신과 같은 타입의 객체를 인자로 받는다.
	디폴트 복사 생성자가 기본으로 생성된다.

복사생성자의 사용처
1. 객체가 함수에 인수로 전달될 때
2. 함수가 객체를 반환값으로 반환할 때
3. 새로운 객체를 같은 클래스 타입의 기존 객체와 똑같이 초기화 할때.

### 디폴트 복사 생성자
```C++
class Test {

public:
	Test(const Test& obj) {  // copy constructor
		...
	}
}
```
왜 const Test obj 이 아닌 const Test& obj인가?
	객체의 경우 차지하는 메모리가 일반적으로 크다.
	복사할객체를 매개변수 obj에 복사후 obj를 새로운 객체에 복사하는 것은 비효율적이다.
	따라서 레퍼런스 타입으로 정의함으로써 기존 객체를 직접 이용해 새 객체에 복사하는 것이다.

왜 const인가?
	const 타입의 변수는 값변경을 할수없고 읽기만 할 수 있다.
	즉 원본값이 변경되지 않고 복사만 할 수 있게한 조치이다.

디폴트 복사 생성자의 주의점
	얕은 복사를 수행한다.
	얕은 복사는 동적할당된 변수를 복사할때 문제가 될 수 있다.

### 얕은 복사와 깊은 복사.
얕은복사 : 값을 복사하는 것이 아닌, 값을 가리키는 포인터를 복사하는 것.
객체 복사에서 문제가 발생할 수 있다. 특히 힙 영역을 참조할때.

필드에 동적할당을 받아 초기화되는 변수가 있다면
디폴트 복사생성자가 아닌, 사용자가 직접정의한
깊은복사를 수행하는 복사 생성자를 정의해야 한다.


## 복사 대입 연산자

### 오버로딩

- 오버로딩이란 함수의 이름이 같아도 매개변수를 다르게 하여 선언 & 정의하는 것이다.
```C++
Fixed& operator=(const Fixed& fixed);
```
## 소멸자


# ex00

## Floating Point (부동소수점)

## Fixed Point (고정소수점)


# 헷갈리는 점

fraction이 static const int인데 도저히 어떻게 손대야 할지 모르겠다.'


# ex02

## 증감연산자

※ 후위 연산자를 오버로딩 하기 위해서 매개 변수로 int를 넘기는데 이때 int는 특별한 의미를 가지는 것이 아니라 전위/후위 연산자의 구분을 위한 것이다.

## min, max 구현

https://www.cplusplus.com/reference/algorithm/max/
같을때는 앞에 인자를 반환한다.

- min,max함수 내부에서 A < B를 호출하는데 빨간줄로 오류가 표시된다.
	비교연산자들 구현에서 함수원형뒤에 const를 붙이니 오류가 사라졌다.
	const에 대한 개념을 확실히 잡고가야 한다.

함수원형뒤에 Const에 대한 기능 추측...

함수의 파라미터로 const를 붙이면
내부에서 실행되는 함수들은 함수원형뒤에 const를 붙인함수(=읽기전용함수)만 실행할 수 있다.

그럼 직접 값을 변경할 수 있을까?


# [42]
```C++
std::ostream& operator<< (std::ostream& out, const Fixed& fixed)
{
	out << fixed.toFloat();
	return (out);
}
```
왜 out이 const가 아니고 참조자로 받도록 되어잇을까?

- const가 아닌 이유.
	const로 선언했다면 const객체가 됨과 동시에 const멤버함수만 쓸 수 있다.
	그런데 우리는 ostream의 멤버함수를 작성하는게 아니라
	ostream과 출력할 객체를 인자로하는 전역함수를 만들고있다.
	이런 전역함수는 const객체로는 접근할 수 없기때문에 out을 const로 하지 않는다.

- 참조자로 받은 이유
	ostream은 굉장히 큰 객체일 것이다.
	이런 큰 객체는 파라미터로 복사하면 매우 비효율적이기 때문에 call by reference로 넘겨줄 필요가
	있지 않을까 예상해본다.

# 함수의 반환값을 const로 하는 이유는 무엇일까?


# 이항연산자를 구현시..

- 덧셈법칙이 통용되지 않을 수 있어서
해당 연산자는 전역에 선언하는 것이 덧셈법칙을 만족한다.
